<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="sql_support">
  <title>SQL Support</title>
  <para>
    Teiid supports SQL for issuing queries and for defining view
    transformations; see also <link linkend="procedure_language">Procedure Language</link>
    for how SQL is used in virtual procedures and update procedures.
  </para>
  <para>
    Teiid provides nearly all of the functionality of SQL-92 DML.
    SQL-99 and later features are constantly being added based upon
    community need. The following does not attempt to cover SQL
    exhaustively, but rather highlights SQL's usage within Teiid. See
    the
    <link linkend="grammar">grammar</link>
    for the exact form of SQL accepted by Teiid.
  </para>
  <section id="identifiers">
    <title>Identifiers</title>
    <para> SQL commands contain references to tables and columns. These
      references are in the form of identifiers, which uniquely identify
      the tables and columns in the context of the command. All queries
      are processed in the context of a virtual database, or VDB.
      Because information can be federated across multiple sources,
      tables and columns must be scoped in some manner to avoid
      conflicts. This scoping is provided by schemas, which contain the
      information for each data source or set of views.</para>
    <itemizedlist>
      <para>Fully-qualified table and column names are of
        the following form, where the separate 'parts' of the identifier
        are delimited by periods.</para>
      <listitem>
        <para>TABLE: &lt;schema_name&gt;.&lt;table_spec&gt;</para>
      </listitem>
      <listitem>
        <para>COLUMN: &lt;schema_name&gt;.&lt;table_spec&gt;.&lt;column_name&gt;</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <para><emphasis>Syntax Rules:</emphasis></para>
      <listitem>
        <para>Identifiers can consist of alphanumeric characters,
          or the underscore (_) character, and must begin with an alphabetic
          character. Any Unicode character may be used in an identifier.
        </para>
      </listitem>
      <listitem>
        <para>Identifiers in double quotes can have any contents.  
        The double quote character can it's be escaped with an additional double quote. e.g. "some "" id"
        </para>
      </listitem>
      <listitem>
        <para> Because different data sources organize tables in different
          ways, some prepending catalog or schema or user information,
          Teiid allows table specification to be a dot-delimited construct.
          <note>
	        <para>When a table specification contains a dot resolving will allow for the match of
	        a partial name against any number of the end segments in the name.  e.g. a table with the 
	        fully-qualified name vdbname."sourcescema.sourcetable" would match the partial name
	        sourcetable.
	        </para>
          </note>
        </para>
      </listitem>
      <listitem>
        <para> Columns, schemas, and aliases identifiers cannot contain a dot.  
        </para>
      </listitem>
      <listitem>
        <para> Identifiers, even when quoted, are not case-sensitive in Teiid.</para>
      </listitem>      
    </itemizedlist>
    <itemizedlist>
      <para> Some examples of valid fully-qualified table identifiers are:
      </para>
      <listitem>
        <para>MySchema.Portfolios
        </para>
      </listitem>
      <listitem>
        <para>"MySchema.Portfolios"
        </para>      
      </listitem>
      <listitem>
        <para>MySchema.MyCatalog.dbo.Authors
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <para>Some examples of valid fully-qualified column identifiers
        are:</para>
      <listitem>
        <para>MySchema.Portfolios.portfolioID
        </para>
      </listitem>
      <listitem>
        <para>"MySchema.Portfolios"."portfolioID" 
        </para>
      </listitem>
      <listitem>
        <para>MySchema.MyCatalog.dbo.Authors.lastName
        </para>
      </listitem>
    </itemizedlist>
    <para> Fully-qualified identifiers can always be used in SQL commands.
      Partially- or unqualified forms can also be used, as long as the
      resulting names are unambiguous in the context of the command.
      Different forms of qualification can be mixed in the same query.
    </para>
  </section>
  <section>
    <title>Expressions</title>
    <para> Identifiers, literals, and functions can be combined into
      expressions. Expressions can be used almost anywhere in a query --
      SELECT, FROM (if specifying join criteria), WHERE, GROUP BY, HAVING, or ORDER BY.</para>
    <itemizedlist>
      <para>Teiid supports the following types of expressions:
      </para>
      <listitem>
        <para><link linkend="columnidentifiers">Column identifiers</link></para>
      </listitem>
      <listitem>
        <para><link linkend="literals">Literals</link></para>
      </listitem>
      <listitem>
        <para><link linkend="scalar_functions">Scalar functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="aggregate_functions">Aggregate functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="case">Case and searched case</link></para>
      </listitem>
      <listitem>
        <para><link linkend="scalar_subqueries">Scalar subqueries</link></para>
      </listitem>
      <listitem>
        <para><link linkend="parameter_references">Parameter references</link></para>
      </listitem>
    </itemizedlist>
    <section id="columnidentifiers">
      <title>Column Identifiers</title>
      <para>
        Column identifiers are used to specify the output columns in SELECT
        statements, the columns and their values for INSERT and UPDATE
        statements, and criteria used in WHERE and FROM clauses. They are
        also used in GROUP BY, HAVING, and ORDER BY clauses. The syntax for
        column identifiers was defined in the
        <link linkend="identifiers">Identifiers</link>
        section above.
      </para>
    </section>
    <section id="literals">
      <title>Literals</title>
      <para>
      Literal values represent fixed values. These can any of the 'standard' <link linkend="datatypes">data types</link>. 
      </para>
      <itemizedlist>
        <para>Syntax Rules:</para>
        <listitem>
          <para>Integer values will be assigned an integral data type big enough to hold the value (integer, long, or biginteger).</para>
        </listitem>
        <listitem>
          <para>Floating point values will always be parsed as a double.</para>
        </listitem>
        <listitem>
          <para>The keyword 'null' is used to represent an absent or unknown value and is inherently untyped. In many cases, a null literal value will be assigned an implied type based on context. For example, in the function '5 + null', the null value will be assigned the type 'integer' to match the type of the value '5'. A null literal used in the SELECT clause of a query with no implied context will be assigned to type 'string'.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <para>Some examples of simple literal values are:</para>
        <listitem>
          <para><literal>‘abc’</literal></para>
        </listitem>
        <listitem>
          <para><literal>‘isn’’t true’</literal> - use an extra single tick to escape a tick in a string with single ticks</para>
        </listitem>
        <listitem>
          <para><literal>5</literal></para>
        </listitem>
        <listitem>
          <para><literal>-37.75e01</literal> - scientific notation</para>
        </listitem>
        <listitem>
          <para><literal>100.0</literal> - parsed as double</para>
        </listitem>
        <listitem>
          <para><literal>true</literal></para>
        </listitem>
        <listitem>
          <para><literal>false</literal></para>
        </listitem>
        <listitem>
          <para><literal>'\u0027'</literal> - unicode character</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="aggregate_functions">
      <title>Aggregate Functions</title>
      <para>Aggregate functions take sets of values from a group produced by an explicit or implicit GROUP BY and return a single scalar value computed from the group.</para>
      <itemizedlist>
        <para>Teiid supports the following aggregate functions:</para>
        <listitem>
          <para>COUNT(*) – count the number of values (including nulls and duplicates) in a group</para>
        </listitem>
        <listitem>
          <para>COUNT(x) – count the number of values (excluding nulls) in a group</para>
        </listitem>
        <listitem>
          <para>SUM(x) – sum of the values (excluding nulls) in a group</para>
        </listitem>
        <listitem>
          <para>AVG(x) – average of the values (excluding nulls) in a group</para>
        </listitem>
        <listitem>
          <para>MIN(x) – minimum value in a group (excluding null)</para>
        </listitem>
        <listitem>
          <para>MAX(x) – maximum value in a group (excluding null)</para>
        </listitem>
        <listitem>
          <para>ANY(x)/SOME(x) – returns TRUE if any value in the group is TRUE (excluding null)</para>
        </listitem>
        <listitem>
          <para>EVERY(x) – returns TRUE if every value in the group is TRUE (excluding null)</para>
        </listitem>
        <listitem>
          <para>VAR_POP(x) – biased variance (excluding null) logically equals (sum(x^2) - sum(x)^2/count(x))/count(x); returns a double; null if count = 0</para>
        </listitem>
        <listitem>
          <para>VAR_SAMP(x) – sample variance (excluding null) logically equals (sum(x^2) - sum(x)^2/count(x))/(count(x) - 1); returns a double; null if count &lt; 2</para>
        </listitem>
        <listitem>
          <para>STDDEV_POP(x) – standard deviation (excluding null) logically equals SQRT(VAR_POP(x))</para>
        </listitem>
        <listitem>
          <para>STDDEV_SAMP(x) – sample standar deviation (excluding null) logically equals SQRT(VAR_SAMP(x))</para>
        </listitem>
        <listitem>
          <para>TEXTAGG(FOR (expression [as name], ... [DELIMITER char] [QUOTE char] [HEADER] [ENCODING id]
          <link linkend="orderby_clause">[ORDER BY ...]</link>) –  CSV text aggregation of all expressions in each row of a group.
          When DELIMITER is not specified, by default comma(,) is used as delimiter. Double quotes(") is the default quote character.  
          Use QUOTE to specify a differnt value.  All non-null values will be quoted. 
          If HEADER is specified, the result contains the header row as the first line - the header line will be present even if there are no rows in a group. 
          This aggregation returns a blob. 
          </para>
        </listitem>                
        <listitem>
          <para>XMLAGG(xml_expr <link linkend="orderby_clause">[ORDER BY ...]</link>) – xml concatination of all xml expressions in a group (excluding null)</para>
        </listitem>                
      </itemizedlist>
      <itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>Some aggregate functions may contain a keyword 'DISTINCT' before the expression, indicating that duplicate expression values should be ignored. DISTINCT is not allowed in COUNT(*) and is not meaningful in MIN or MAX (result would be unchanged), so it can be used in COUNT, SUM, and AVG.
          </para>
        </listitem>
        <listitem>
          <para>Aggregate functions may only be used in the HAVING or SELECT clauses and may not be nested within another aggregate function.
          </para>
        </listitem>
        <listitem>
          <para>Aggregate functions may be nested inside other functions.
          </para>
        </listitem>
      </itemizedlist>
      <para>
      For more information on aggregates, see the sections on GROUP BY or HAVING.
      </para>
    </section>
    <section id="case">
      <title>Case and searched case</title>
      <para>
      Teiid supports two forms of the CASE expression which allows conditional logic in a scalar expression.
      </para>
      <itemizedlist>
        <para>Supported forms:
        </para>
        <listitem>
          <para>CASE &lt;expr&gt; ( WHEN &lt;expr&gt; THEN &lt;expr&gt;)+ [ELSE expr] END
          </para>
        </listitem>
        <listitem>
          <para>CASE ( WHEN &lt;criteria&gt; THEN &lt;expr&gt;)+ [ELSE expr] END
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Each form allows for an output based on conditional logic. The first
        form starts with an initial expression and evaluates WHEN expressions
        until the values match, and outputs the THEN expression. If no WHEN is
        matched, the ELSE expression is output. If no WHEN is matched and no
        ELSE is specified, a null literal value is output. The second form
        (the searched case expression) searches the WHEN clauses, which
        specify an arbitrary criteria to evaluate. If any criteria evaluates
        to true, the THEN expression is evaluated and output. If no WHEN is
        true, the ELSE is evaluated or NULL is output if none exists.</para>
    </section>
    <section id="scalar_subqueries">
      <title>Scalar subqueries</title>
      <para>
        Subqueries can be used to produce a single scalar value in the SELECT,
        WHERE, or HAVING clauses only. A scalar subquery must have a single
        column in the SELECT clause and should return either 0 or 1 row. If no
        rows are returned, null will be returned as the scalar subquery value.
        For other types of subqueries, see the
        <link linkend="subqueires">Subqueries</link>
        section below.</para>
    </section>
    <section id="parameter_references">
      <title>Parameter references</title>
      <para> Parameters are specified using a '?' symbol. Parameters may
        only be used with PreparedStatement or CallableStatements in JDBC.
        Each parameter is linked to a value specified by 1-based index in
        the JDBC API.</para>
    </section>
  </section>
  <section id="criteria">
    <title>Criteria</title>
    <itemizedlist>
      <para>Criteria may be:
      </para>
      <listitem>
        <para>Predicates that evaluate to true or false
        </para>      
      </listitem>
      <listitem>
        <para>Logical criteria that combines criteria (AND, OR, NOT)
        </para>      
      </listitem>
      <listitem>
        <para>A value expression with type boolean
        </para>      
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <para>Syntax Rules:
      </para>
      <listitem>
        <para>expression (=|&lt;&gt;|!=|&lt;|>|&lt;=|>=) (expression|((ANY|ALL|SOME) subquery))
        </para>
      </listitem>
      <listitem>
        <para>expression [NOT] IS NULL
        </para>
      </listitem>
      <listitem>
        <para>expression [NOT] IN (expression[,expression]*)|subquery
        </para>
      </listitem>
      <listitem>
        <para>expression [NOT] LIKE expression [ESCAPE char]
        </para>
      </listitem>
      <listitem>
        <para>EXISTS(subquery)
        </para>
      </listitem>
      <listitem>
        <para>expression BETWEEN minExpression AND maxExpression
        </para>
      </listitem>
      <listitem>
        <para>criteria AND|OR criteria
        </para>
      </listitem>
      <listitem>
        <para>NOT criteria
        </para>
      </listitem>
      <listitem>
        <para>expression
        </para>
      </listitem>
      <listitem>
        <para>Criteria may be nested using parenthesis.
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <para>Some examples of valid criteria are:
      </para>
      <listitem>
        <para>(balance &gt; 2500.0)
        </para>
      </listitem>
      <listitem>
        <para>100*(50 - x)/(25 - y) &gt; z
        </para>
      </listitem>
      <listitem>
        <para>concat(areaCode,concat('-',phone)) LIKE '314%1'
        </para>
      </listitem>
    </itemizedlist>
    <note>
      <title>Comparing null Values</title>
      <para>Null values represent an unknown value. Comparison with a null value will evaluate to 'unknown', which can never be true even if 'not' is used.</para>
    </note>
  </section>
  <section id="sql_commands">
    <title>SQL Commands</title>
    <para>There are 4 basic commands for manipulating data in SQL, corresponding to the CRUD create, read, update, and delete operations: INSERT, SELECT, UPDATE, and DELETE. In addition, procedures can be executed using the EXECUTE command or through a <link linkend="procedural_relational">procedural relational command</link>.</para>
    <section id="select_command">
      <title>SELECT Command</title>
      <para>The SELECT command is used to retrieve records any number of relations.</para> 
      <itemizedlist>
        <para>A SELECT command has a number of clauses:</para>
        <listitem>  
          <para>
            <link linkend="with_clause">WITH ...</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="select_clause">SELECT ...</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="from_clause">[FROM ...]</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="where_clause">[WHERE ...]</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="groupby_clause">[GROUP BY ...]</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="having_clause">[HAVING ...]</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="orderby_clause">[ORDER BY ...]</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="limit_clause">[LIMIT [offset,] limit]</link>
          </para>
        </listitem>
        <listitem>  
          <para>
            <link linkend="option_clause">[OPTION ...]</link>
          </para>
        </listitem>
      </itemizedlist>
      <para>
        All of these clauses other than OPTION are defined by the SQL specification. The specification also specifies the order that these clauses will be logically processed. Below is the processing order where each stage passes a set of rows to the following stage. Note that this processing model is logical and does not represent the way any actual database engine performs the processing, although it is a useful model for understanding questions about SQL.
      </para>
      <itemizedlist>
        <listitem>
          <para>WITH stage - gathers all rows from all with items in the order listed.  Subsequent with items and the main query can reference the a with item as if it is a table.
          </para>
        </listitem>
        <listitem>
          <para>FROM stage - gathers all rows from all tables involved in the query and logically joins them with a Cartesian product, producing a single large table with all columns from all tables. Joins and join criteria are then applied to filter rows that do not match the join structure.
          </para>
        </listitem>
        <listitem>
          <para>WHERE stage - applies a criteria to every output row from the FROM stage, further reducing the number of rows.
          </para>
        </listitem>
        <listitem>
          <para>GROUP BY stage - groups sets of rows with matching values in the group by columns.
          </para>
        </listitem>
        <listitem>
          <para>HAVING stage - applies criteria to each group of rows. Criteria can only be applied to columns that will have constant values within a group (those in the grouping columns or aggregate functions applied across the group).
          </para>
        </listitem>
        <listitem>
          <para>SELECT stage - specifies the column expressions that should be returned from the query. Expressions are evaluated, including aggregate functions based on the groups of rows, which will no longer exist after this point. The output columns are named using either column aliases or an implicit name determined by the engine. If SELECT DISTINCT is specified, duplicate removal will be performed on the rows being returned from the SELECT stage.
          </para>
        </listitem>
        <listitem>
          <para>ORDER BY stage - sorts the rows returned from the SELECT stage as desired. Supports sorting on multiple columns in specified order, ascending or descending. The output columns will be identical to those columns returned from the SELECT stage and will have the same name.
          </para>
        </listitem>
        <listitem>
          <para>LIMIT stage - returns only the specified rows (with skip and limit values).
          </para>
        </listitem>
      </itemizedlist>
      <para> This model can be used to understand many questions about SQL.
        For example, columns aliased in the SELECT clause can only be
        referenced by alias in the ORDER BY clause. Without knowledge of the
        processing model, this can be somewhat confusing. Seen in light of
        the model, it is clear that the ORDER BY stage is the only stage
        occurring after the SELECT stage, which is where the columns are
        named. Because the WHERE clause is processed before the SELECT, the
        columns have not yet been named and the aliases are not yet known.
      </para>
      <note>
        <para>
	      The explicit table syntax <code>TABLE x</code> may be used as a shortcut for <code>SELECT * FROM x</code>.
	    </para>
      </note>
    </section>
    <section id="insert_command">
      <title>INSERT Command</title>
      <para>The INSERT command is used to add a record to a table.</para>
      <itemizedlist>
        <para>Example Syntax</para>
        <listitem>
          <para>INSERT INTO table (column,...) VALUES (value,...)
          </para>
        </listitem>
        <listitem>
          <para>INSERT INTO table (column,...) query
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="update_command">
      <title>UPDATE Command</title>
      <para>The UPDATE command is used to modify records in a table. The operation may result in 1 or more records being updated, or in no records being updated if none match the criteria.</para>
      <itemizedlist>
        <para>Example Syntax</para>
        <listitem>
          <para>UPDATE table SET (column=value,...) [WHERE criteria]
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="delete_command">
      <title>DELETE Command</title>
      <para>The DELETE command is used to remove records from a table. The operation may result in 1 or more records being deleted, or in no records being deleted if none match the criteria. </para>
      <itemizedlist>
        <para>Example Syntax</para>
        <listitem>
          <para>DELETE FROM table [WHERE criteria]
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="exec_command">
      <title>EXECUTE Command</title>
      <para>The EXECUTE command is used to execute a procedure, such as a virtual procedure or a stored procedure. Procedures may have zero or more scalar input parameters. The return value from a procedure is a result set, the same as is returned from a SELECT. Note that EXEC or CALL can be used as a short form of this command. 
      </para>
      <itemizedlist>
        <para>Example Syntax</para>
        <listitem>
          <para>EXECUTE proc()
          </para>
        </listitem>
        <listitem>
          <para>EXECUTE proc(value, ...)
          </para>
        </listitem>
        <listitem>
          <para>EXECUTE proc(name1=>value1,name4=>param4, ...) - named parameter syntax
          </para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>The default order of parameter specification is the same
          as how they are defined in the procedure definition.
          </para>
        </listitem>
        <listitem>
          <para>You can specify the parameters in any order by name. Parameters that are have
          default values and/or are nullable in the metadata, can be omitted
          from the named parameter call and will have the appropriate value
          passed at runtime.
          </para>
        </listitem>
        <listitem>
          <para>If the procedure does not return a result set, the values from the RETURN, OUT, and IN_OUT parameters will be returned as a single row when used as an inline view query.
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="procedural_relational">
	  <title>Procedural Relational Command</title>
      <para> Procedural relational commands use the syntax of a SELECT to
		emulate an EXEC. In a procedural relational command a procedure group
		names is used in a FROM clause in place of a table. That procedure
		will be executed in place of a normal table access if all of the
		necessary input values can be found in criteria against the procedure.  
		Each combination of input values found in the criteria results in an execution of the procedure.
	  </para>
	  <para>
	    <itemizedlist>
          <para>Example Syntax</para>
          <listitem>
            <para>select * from proc
            </para>
          </listitem>
          <listitem>
            <para>select output_param1, output_param2 from proc where input_param1 = 'x'
            </para>
          </listitem>
          <listitem>
            <para>select output_param1, output_param2 from proc, table where input_param1 = table.col1 and input_param2 = table.col2
            </para>
          </listitem>
        </itemizedlist>
	    <itemizedlist>
          <para>Syntax Rules:</para>
          <listitem>
	        <para>The procedure as a table projects the same columns as an exec with the addition of the input parameters.
		      For procedures that do not return a result set, IN_OUT columns will be projected as two columns, one that represents
		      the output value and one named {column name}_IN that represents the
		      input of the parameter.</para>
          </listitem>
          <listitem>
            <para>Input values are passed via criteria. Values can be passed by '=','is null', or 'in' predicates.  Disjuncts are not allowed.  
            It is also not possible to pass the value of a non-comparable column through an equality predicate.
            </para>
          </listitem>
          <listitem>
            <para>The procedure view automatically has an access pattern on its IN and IN_OUT parameters which
            allows it to be planned correctly as a dependent join when necessary or fail when sufficient criteria cannot be found.
            </para>
          </listitem>
          <listitem>
            <para>Procedures containing duplicate names between the parameters (IN, IN_OUT, OUT, RETURN) and result set columns 
            cannot be used in a procedural relational command.
            </para>
          </listitem>
          <listitem>
            <para>Default values for IN, IN_OUT parameters are not used if there is no criteria present for a given input.  Default values are
            only valid for <link linkend="exec_command">named procedure syntax</link>.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <note>
		<title>Multiple Execution</title>
		  <para>The usage of 'in' or join criteria can result in
				the procedure being executed multiple times.</para>
	  </note>
	  <note>
	  	<title>Alternative Syntax</title>
	  	<para>
	  		None of issues listed in the syntax rules above exist if a <link linkend="nested_table">nested table reference</link> is used. 
	  	</para>
	  </note>
    </section>
  </section>
  <section id="temp_tables">
    <title>Temp Tables</title>
    <para>Teiid supports creating temporary,or "temp", tables. Temp tables are dynamically created, but are treated as any other physical table.
    </para>
    <para>
      Temp tables can be defined implicitly by referencing them in a
      INSERT statement or explicitly with a CREATE TABLE
      statement. Implicitly created temp tables must have a name that
      starts with '#'.
    </para>
    <itemizedlist>
      <para>Creation syntax:
      </para>
      <listitem>
        <para>Explicit: CREATE LOCAL TEMPORARY TABLE x (column type [NOT NULL], ... [PRIMARY KEY (column, ...)])
        </para>
      </listitem>
      <listitem>
        <para>Implicit: INSERT INTO #x (column, ...) VALUES (value, ...) 
        </para>
        <para>If #x doen't exist, it will be defined using the given column names and types from the value expressions.
        </para>
      </listitem>
      <listitem>
        <para>Implicit: INSERT INTO #x [(column, ...)] select c1, c2 from t
        </para>
        <para>If #x doesn't exist, it will be defined using the target column names (in not supplied, the column names will match the derived column names from the query), and the types from the query derived columns. 
        </para>
      </listitem>
      <listitem>
      	<para>Use the SERIAL data type to specify a NOT NULL and auto-incrementing INTEGER column.  The starting value of a SERIAL column is 1.</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <para>Drop syntax:
      </para>
      <listitem>
        <para>DROP TABLE x
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
    	<para>Primary Key Support</para>
    	<listitem>
        	<para>All key columns must be comparable.</para>
      	</listitem>
      	<listitem>
        	<para>Use of a primary key creates a clustered index that supports search improvements for comparison, in, like, and order by.</para>
      	</listitem>
      	<listitem>
        	<para>Null is an allowable primary key value, but there must be only 1 row that has an all null key.</para>
      	</listitem>
    </itemizedlist>
    <itemizedlist>
      <para>Limitations:
      </para>
      <listitem> 
        <para>With the CREATE TABLE syntax only basic table definition (column name and type information) and an optional primary key are supported.
        </para>
      </listitem>
      <listitem> 
        <para>The "ON COMMIT" clause is not supported in the CREATE TABLE statement.
        </para>
      </listitem>
      <listitem> 
        <para>"drop behavior" option is not supported in the drop statement.
        </para>
      </listitem>
      <listitem> 
        <para>Only local temporary tables are supported. This implies that the scope of temp table will be either to the sesssion or the block of a virtual procedure that creates it.
        </para>
      </listitem>
      <listitem>
        <para>Session level temp tables are not fail-over safe.
        </para>    
      </listitem>    
      <listitem>
        <para>Temp tables are non-transactional.
        </para>    
      </listitem>  
      <listitem>
        <para>Lob values (xml, clob, blob) are tracked by reference rather than by value in a temporary table.  
        Lob values from external sources that are inserted in a temporary table may become unreadable when the associated statement or connection is closed.
        </para>    
      </listitem>    
    </itemizedlist>
    <para>The following example is a series of statements that loads a temporary table with data from 2 sources, and with a manually inserted record, and then uses that temp table in a subsequent query.</para>
    <programlisting>... 
CREATE LOCAL TEMPORARY TABLE TEMP (a integer, b integer, c integer); 
SELECT * INTO temp FROM Src1; SELECT * INTO temp FROM Src2; 
INSERT INTO temp VALUES (1,2,3); 
SELECT a,b,c FROM Src3, temp WHERE Src3.a = temp.b; 
...</programlisting>
    <para>
      See <link linkend="virtual_procedures">virtual procedures</link> for more on temp table usage.
    </para>
  </section>
  <section>
    <title>SQL Clauses</title>
    <para>This section describes the clauses that are used in the various <link linkend="sql_commands">SQL commands</link> described in the previous section. Nearly all these features follow standard SQL syntax and functionality, so any SQL reference can be used for more information.</para>
    <section id="with_clause">
      <title>WITH Clause</title>
      <para>
      Teiid supports non-recursive common table expressions via the WITH clause.  With clause items may be referenced as tables in subsequent with clause items and in the main query.  The WITH clause can be thought of as providing query scoped temporary tables.
      </para>
      <para>
        Usage:
        <synopsis label="Usage">WITH name [(column, ...)] AS (query expression) ... </synopsis>
      </para>
      <itemizedlist>
        <para>Syntax Rules:</para>
        <listitem><para>All of the projected column names must be unique.  If they are not unique, then the column name list must be provided.</para></listitem>
        <listitem><para>If the columns of the WITH clause item are declared, then they must match the number of columns projected by the query expression.</para></listitem>
        <listitem><para>Each with clause item must have a unique name.</para></listitem>
      </itemizedlist> 
    </section>
    <section id="select_clause">
      <title>SELECT Clause</title>
      <para>
      SQL queries that start with the SELECT keyword and are often referred to as "SELECT statements". Teiid supports most of the standard SQL query constructs.
      </para>
      <para>
        Usage:
        <synopsis label="Usage">SELECT [DISTINCT|ALL] ((expression [[AS] name])|(group identifier.STAR))*|STAR ...</synopsis>
      </para>
      <itemizedlist>
        <para>Syntax Rules:</para>
        <listitem><para>Aliased expressions are only used as the output column names and in the ORDER BY clause. They cannot be used in other clauses of the query.</para></listitem>
        <listitem><para>DISTINCT may only be specified if the SELECT symbols are comparable.</para></listitem>
      </itemizedlist> 
    </section>
    <section id="from_clause">
      <title>FROM Clause</title>
      <para>
      The FROM clause specifies the target table(s) for SELECT, UPDATE, and DELETE statements. 
      </para>
      <itemizedlist>
        <para>Example Syntax:</para>
        <listitem><para>FROM table [[AS] alias]</para></listitem>
        <listitem><para>FROM table1 [INNER|LEFT OUTER|RIGHT OUTER|FULL OUTER] JOIN table2 ON join-criteria</para></listitem>
        <listitem><para>FROM table1 CROSS JOIN table2</para></listitem>
        <listitem><para>FROM (subquery) [AS] alias</para></listitem>
        <listitem><para>FROM <link linkend="nested_table">TABLE(subquery)</link> [AS] alias</para></listitem>
        <listitem><para>FROM table1 JOIN table2 MAKEDEP ON join-criteria</para></listitem>
        <listitem><para>FROM table1 JOIN table2 MAKENOTDEP ON join-criteria</para></listitem>
        <listitem><para>FROM table1 left outer join <link linkend="optional_join">/*+ optional */</link> table2 ON join-criteria</para></listitem>
        <listitem><para>FROM <link linkend="texttable">TEXTTABLE...</link></para></listitem>
        <listitem><para>FROM <link linkend="xmltable">XMLTABLE...</link></para></listitem>
        <listitem><para>FROM <link linkend="arraytable">ARRAYTABLE...</link></para></listitem>
      </itemizedlist> 
      <note>
        <title>DEP Hints</title>
        <para>
          MAKEDEP and MAKENOTDEP are hints used to control
          <link linkend="dependent_joins">dependent join</link>
          behavior. They should only be used in situations where the optimizer
          does not choose the most optimal plan based upon query structure,
          metadata, and costing information.
        </para>
      </note>
      <section id="nested_table">
		<title>Nested Table Reference</title>
		<para>Nested tables may appear in the FROM clause with the TABLE
			keyword. They are an alternative to using a view with normal join
			semantics.  The columns projected from the command contained in the nested table
			 may be used just as any of the other FROM clause projected columns in join criteria, the where clause, etc.
      	</para>
		<para>A nested table may have correlated references to preceeding FROM
			clause column references as long as INNER and LEFT OUTER joins are used. This is
			especially useful in cases where then nested expression is a
			procedure or function call.</para>
		<para>Valid example: 
		<programlisting>select * from t1, TABLE(call proc(t1.x)) t2</programlisting>
		</para>
		<para>Invalid example, since t1 appears after the nested table in the from clause: 
		<programlisting>select * from TABLE(call proc(t1.x)) t2, t1</programlisting>
		</para>
		<note>
			<title>Multiple Execution</title>
			<para>The usage of a correlated nested table may result in multiple
				executions of the table expression - once for each correlated row.
			</para>
		</note>
	  </section>
	  <section id="texttable">
		<title>TEXTTABLE</title>
		<para>The TEXTTABLE funciton processes character input to produce tabular ouptut.  It supports both fixed and delimited file format parsing.  
			The function itself defines what columns it projects.  
		    The TEXTTABLE function is implicitly a nested table and may be correlated to preceeding FROM clause entries.
      	</para>
      	<para>
        Usage:
        	<synopsis label="Usage">TEXTTABLE(expression COLUMNS &lt;COLUMN&gt;, ... [DELIMITER char] [(QUOTE|ESCAPE) char] [HEADER [integer]] [SKIP integer]) AS name</synopsis>
        	<synopsis label="Usage">COLUMN := name datatype [WIDTH integer]</synopsis> 
      	</para>
      	<itemizedlist>
        	<para>Parameters</para>
        <listitem>
          <para>expression - the text content to process, which should be convertable to CLOB.
          </para>
        </listitem>
        <listitem>
        	<para>DELIMITER sets the field delimiter character to use.  Defaults to ','.
        	</para>
        </listitem>
        <listitem>
        	<para>QUOTE sets the quote, or qualifier, character used to wrap field values.  Defaults to '"'.  
        	</para>
        </listitem>
        <listitem>
        	<para>ESCAPE sets the escape character to use if no quoting character is in use.  
        	This is used in situations where the delimiter or new line characters are escaped with a preceding character, e.g. \,  
        	</para>
        </listitem>
        <listitem>
        	<para>HEADER specifies the text line number (counting every new line) on which the column names occur.  All lines prior to the header will be skipped.
        	If HEADER is specified, then the header line will be used to determine the TEXTTABLE column position by case-insensitive name matching.  This is especially useful in situations where only a subset of the columns are needed.
        	If the HEADER value is not specified, it defaults to 1.  
        	If HEADER is not specified, then columns are expected to match positionally with the text contents. 
        	</para>
        </listitem>
        <listitem>
        	<para>SKIP specifies the number of text lines (counting every new line) to skip before parsing the contents.  HEADER may still be specified with SKP.
        	</para>
        </listitem>
      	</itemizedlist>
      	<itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>If width is specified for one column it must be specified for all columns.
          </para>
        </listitem>
        <listitem>
          <para>If width is specified, then fixed width parsing is used and ESCAPE, QUOTE, and HEADER should not be specified.
          </para>
        </listitem>
        <listitem>
          <para>The columns names must be not contain duplicates.
          </para>
        </listitem>
        </itemizedlist>
      	<itemizedlist>
        	<para>Examples</para>
        	<listitem>
		        <para>Use of the HEADER parameter, returns 1 row ['b']: <programlisting>select * from texttable('col1,col2,col3\na,b,c' COLUMNS col2 string HEADER) x</programlisting>
				</para>		
        	</listitem>
        	<listitem>
		        <para>Use of fixed width, returns 1 row ['a', 'b', 'c']: <programlisting>select * from texttable('abc' COLUMNS col1 string width 1, col2 string width 1, col3 string width 1) x</programlisting>
				</para>		
        	</listitem>
        	<listitem>
		        <para>Use of ESCAPE parameter, returns 1 row ['a,', 'b']: <programlisting>select * from texttable('a:,,b' COLUMNS col1 string, col2 string ESCAPE ':') x</programlisting>
				</para>		
        	</listitem>
        	<listitem>
		        <para>As a nested table: <programlisting>select x.* from t, texttable(t.clobcolumn COLUMNS first string, second date SKIP 1) x</programlisting>
				</para>		
        	</listitem>
		</itemizedlist>		
	  </section>
	  <section id="xmltable">
		<title>XMLTABLE</title>
		<para>The XMLTABLE funciton uses XQuery to produce tabular ouptut.  
		    The XMLTABLE function is implicitly a nested table and may be correlated to preceeding FROM clause entries.  XMLTABLE is part of the SQL/XML 2006 specification. 
      	</para>
      	<para>
        Usage:
        	<synopsis label="Usage">XMLTABLE([&lt;NSP&gt;,] xquery-expression [&lt;PASSING&gt;] [COLUMNS &lt;COLUMN&gt;, ... )] AS name</synopsis>
        	<synopsis label="Usage">COLUMN := name (FOR ORDINALITY | (datatype [DEFAULT expression] [PATH string]))</synopsis> 
      	</para>
      	<para>See XMLELEMENT for the definition of NSP - <link linkend="xmlnamespaces">XMLNAMESPACES</link>.</para>
      	<para>See XMLQUERY for the definition of <link linkend="passing">PASSING</link>.</para>
      	<para>See also <link linkend="xmlquery">XMLQUERY</link></para>
      	<itemizedlist>
        	<para>Parameters</para>
        <listitem>
        	<para>The optional XMLNAMESPACES clause specifies the namepaces for use in the XQuery and COLUMN path expressions.
        	</para>
        </listitem>
        <listitem>
        	<para>The xquery-expression should be a valid XQuery.  Each sequence item returned by the xquery will be used to create a row of values as defined by the COLUMNS clause.
        	</para>
        </listitem>
        <listitem>
        	<para>If COLUMNS is not specified, then that is the same as having the COLUMNS clause: "COLUMNS OBJECT_VALUE XML PATH '.'", which returns the entire item as an XML value.  Each non-ordinality column specifies a type and optionally a PATH and a DEFAULT expression.  
        	If PATH is not specified, then the path will be the same as the column name.  A FOR ORDINALITY column is typed as integer and will return the 1-based item number as its value.    
        	</para>
        </listitem>
      	</itemizedlist>
      	<itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>Only 1 FOR ORDINALITY column may be specified.
          </para>
        </listitem>
        <listitem>
          <para>The columns names must be not contain duplicates.
          </para>
        </listitem>
        </itemizedlist>
      	<itemizedlist>
        	<para>Examples</para>
        	<listitem>
		        <para>Use of passing, returns 1 row [1]: <programlisting>select * from xmltable('/a' PASSING xmlparse(document '&lt;a id="1"/&gt;') COLUMNS id integer PATH '@id') x</programlisting>
				</para>		
        	</listitem>
        	<listitem>
		        <para>As a nested table: <programlisting>select x.* from t, xmltable('/x/y' PASSING t.doc COLUMNS first string, second FOR ORDINALITY) x</programlisting>
				</para>		
        	</listitem>
		</itemizedlist>		
	  </section>
    </section>
    	  <section id="arraytable">
		<title>ARRAYTABLE</title>
		<para>The ARRAYTABLE funciton processes an array input to produce tabular ouptut.  
			The function itself defines what columns it projects.  
		    The ARRAYTABLE function is implicitly a nested table and may be correlated to preceeding FROM clause entries.
      	</para>
      	<para>
        Usage:
        	<synopsis label="Usage">ARRAYTABLE(expression COLUMNS &lt;COLUMN&gt;, ...) AS name</synopsis>
        	<synopsis label="Usage">COLUMN := name datatype</synopsis> 
      	</para>
      	<itemizedlist>
        	<para>Parameters</para>
        <listitem>
          <para>expression - the array to process, which should be a java.sql.Array or java array value.
          </para>
        </listitem>
      	</itemizedlist>
      	<itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>The columns names must be not contain duplicates.
          </para>
        </listitem>
        </itemizedlist>
      	<itemizedlist>
        	<para>Examples</para>
        	<listitem>
		        <para>As a nested table: <programlisting>select x.* from (call source.invokeMDX('some query')) r, arraytable(r.tuple COLUMNS first string, second bigdecimal) x</programlisting>
				</para>		
        	</listitem>
		</itemizedlist>
		<para>ARRAYTABLE is effectively a shortcut for using the <xref linkend="array_get"/> function in a nested table.  For example "ARRAYGET(val COLUMNS col1 string, col2 integer) AS X" is the same as "TABLE(SELECT cast(array_get(val, 1) AS string) AS col1, cast(array_get(val, 2) AS integer) AS col2) AS X".</para>		
	  </section>
    <section id="where_clause">
      <title>WHERE Clause</title>
      <para>
      The WHERE clause defines the criteria to limit the records affected by SELECT, UPDATE, and DELETE statements.  
      </para>
      <itemizedlist>
        <para>The general form of the WHERE is:
        </para>
        <listitem>
          <para>WHERE <link linkend="criteria">criteria</link>
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="groupby_clause">
      <title>GROUP BY Clause</title>
      <para>
      The GROUP BY clause denotes that rows should be grouped according to the specified expression values. One row will be returned for each group, after optionally filtering those aggregate rows based on a HAVING clause.   
      </para>
      <itemizedlist>
        <para>The general form of the GROUP BY is:
        </para>
        <listitem>
          <para>GROUP BY expression (,expression)*
          </para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>Column references in the group by clause must by to unaliased output columns.
          </para>
        </listitem>
        <listitem>
          <para>Expressions used in the group by must appear in the select clause.
          </para>
        </listitem>
        <listitem>
          <para>Column references and expessions in the select clause that are not used in the group by clause must appear in aggregate functions. 
          </para>
        </listitem>
        <listitem>
          <para>If an aggregate function is used in the SELECT clause and no
            GROUP BY is specified, an implicit GROUP BY will be performed with
            the entire result set as a single group. In this case, every column
            in the SELECT must be an aggregate function as no other column value
            will be fixed across the entire group. 
          </para>
        </listitem>
        <listitem>
          <para>The group by columns must be of a comparable type.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="having_clause">
      <title>HAVING Clause</title>
      <para>
      The HAVING clause operates exactly as a WHERE clause although it operates on the output of a GROUP BY. It supports the same syntax as the WHERE clause.
      </para>
      <itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>Expressions used in the group by clause must either
            contain an aggregate function: COUNT, AVG, SUM, MIN, MAX. or be one
            of the grouping expressions.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="orderby_clause">
      <title>ORDER BY Clause</title>
      <para>
      The ORDER BY clause specifies how records should be sorted. The options are ASC (ascending) and DESC (descending).
      </para>
      <para>
        Usage:
        <synopsis label="Usage">ORDER BY expression [ASC|DESC] [NULLS (FIRST|LAST)], ...</synopsis>
      </para>
      <itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>Sort columns may be specified positionally by a 1-based positional
	        integer, by SELECT clause alias name, by SELECT clause expression, or by an unrelated expression.</para>
        </listitem>
        <listitem>
          <para>Column references may appear in the SELECT clause as the
			expression for an aliased column or may reference columns from tables
			in the FROM clause.
			If the column reference is not in the SELECT clause the query must not
			be a set operation, specify SELECT DISTINCT, or contain a GROUP BY
			clause.</para>
        </listitem>
        <listitem>
          <para>Unrelated expressions, expressions not appearing as an aliased expression in the select clause, 
          are allowed in the order by clause of a non-set QUERY.  The columns referenced in the expression must come from the
          from clause table references.  The column references cannot be to alias names or positional.
          </para>
        </listitem>
        <listitem>
          <para>The ORDER BY columns must be of a comparable type.</para>
        </listitem>
        <listitem>
          <para>If an ORDER BY is used in an inline view or view
	         definition without a limit clause, it will be removed by the Teiid
	         optimizer.</para>
        </listitem>
        <listitem>
        	<para>If NULLS FIRST/LAST is specified, then nulls are guaranteed to be sorted either first or last.  If the null ordering is not specified, then results will 
        	typically be sorted with nulls as low values, which is Teiid's internal default sorting behavior.   
        	However not all sources return results with nulss sorted as low values by default, and Teiid may return results with different null orderings. 
        	</para>
        </listitem>
      </itemizedlist>
      <warning>
		<para>The use of positional ordering is no longer supported by the
				ANSI SQL standard and is a deprecated feature in Teiid. It is
				preferable to use alias names in the order by clause.</para>
	  </warning>
    </section>
    <section id="limit_clause">
      <title>LIMIT Clause</title>
      <para>
      The LIMIT clause specifies a limit on the number of records returned from the SELECT command. An optional offset (the number of rows to skip) can be specified. 
      </para>
      <para>
        Usage:
        <synopsis label="Usage">LIMIT [offset,] limit</synopsis>
      </para>
      <itemizedlist>
        <para>Examples:
        </para>
        <listitem>
          <para>LIMIT 100 - returns the first 100 records (rows 1-100)</para>
        </listitem>
        <listitem>
          <para>LIMIT 500, 100 - skips 500 records and returns the next 100 records (rows 501-600)</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="into_clause">
      <title>INTO Clause</title>
      <warning>
      	<para>Usage of the INTO Clause for inserting into a table has been been deprecated.  An <link linkend="insert_command">INSERT</link> with a query command should be used instead.</para>
      </warning>
      <para>
      When the into clause is specified with a SELECT, the results of the query are inserted into the specified table. This is often used to insert records into a temporary table. The INTO clause immediately precedes the FROM clause.   
      </para>
      <para>
        Usage:
        <synopsis label="Usage">INTO table FROM ...</synopsis>
      </para>
      <itemizedlist>
        <para>Syntax Rules:
        </para>
        <listitem>
          <para>The INTO clause is logically applied last in processing, after the ORDER BY and LIMIT clauses.</para>
        </listitem>
        <listitem>
          <para>Teiid's support for SELECT INTO is similar to
            MS SQL Server. The target of the INTO clause is a table where
            the result of the rest select command will be inserted. SELECT
            INTO should not be used UNION query.</para>
        </listitem>
      </itemizedlist>
    </section>    
    <section id="option_clause">
      <title>OPTION Clause</title>
      <para>
      The OPTION keyword denotes options the user can pass in with the command. These options are Teiid-specific and not covered by any SQL specification.  
      </para>
      <para>
        Usage:
        <synopsis label="Usage">OPTION option, (option)*</synopsis>
      </para>
      <itemizedlist>
        <para>Supported options:
        </para>
        <listitem>
          <para>MAKEDEP table [(,table)*] - specifies source tables that should be made dependent in the join
          </para>
        </listitem>
        <listitem>
          <para>MAKENOTDEP table [(,table)*] - prevents a dependent join from being used
          </para>
        </listitem>
        <listitem>
          <para>NOCACHE [table (,table)*] - prevents cache from being used for all tables or for the given tables
          </para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <para>Examples:
        </para>
        <listitem>
          <para>OPTION MAKEDEP table1</para>
        </listitem>
        <listitem>
          <para>OPTION NOCACHE</para>
        </listitem>
      </itemizedlist>
      <para>All tables specified in the OPTION clause should be fully qualified.</para>
      <note><para>Previous versions of Teiid accepted the PLANONLY, DEBUG, and SHOWPLAN option arguments.  These are no longer accepted in the OPTION clause.
      Please see the Client Developers Guide for replacements to those options.
      </para></note>
    </section>
  </section>
  <section id="set_operations">
    <title>Set Operations</title>
    <para>Teiid supports the UNION, UNION ALL, INTERSECT, EXCEPT set operation as a way of combining the results of commands.</para>
    <para>
      Usage:
      <synopsis label="Usage">command (UNION|INTERSECT|EXCEPT) [ALL] command [ORDER BY...]</synopsis>
    </para>
    <itemizedlist>
      <para>Syntax Rules:
      </para>
      <listitem>
        <para>The output columns will be named by the output columns of the first set operation branch. 
        </para>      
      </listitem>
      <listitem>
        <para>Each SELECT must have the same number of output columns and compatible data types for each relative column. Data type conversion will be performed if data types are inconsistent and implicit conversions exist.
        </para>
      </listitem>
      <listitem>
        <para>If UNION, INTERSECT, or EXCEPT is specified without all, then the output columns must be comparable types.
        </para>
      </listitem>
      <listitem>
        <para>INTERSECT ALL, and EXCEPT ALL are currently not supported.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section id="subqueries">
    <title>Subqueries</title>
    <para>A subquery is a SQL query embedded within another SQL query. The query containing the subquery is the outer query.</para>
    <itemizedlist>
      <para>Supported subquery types:
      </para>
      <listitem>
        <para>Scalar subquery - a subquery that returns only a single column with a single value.  Scalar subqueries are a type of expression and can be used where single valued expressions are expected.
        </para>
      </listitem>
      <listitem>
        <para>Correlated subquery - a subquery that contains a column reference to from the outer query.
        </para>
      </listitem>
      <listitem>
        <para>Uncorrelated subquery - a subquery that contains no references to the outer sub-query.
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <para>Supported subquery locations:
      </para>
      <listitem>
        <para><link linkend="from_subquery">Subqueries in the FROM clause</link></para>
      </listitem>
      <listitem>
        <para><link linkend="where_subquery">Subqueries in the WHERE/HAVING Clauses</link></para>
      </listitem>
      <listitem>
        <para>Subqueries may be used in any expression or CASE CRITERIA in the SELECT clasue.</para>
      </listitem>
    </itemizedlist>
    <section id="from_subquery">
      <title>Inline views</title>
      <para> Subqueries in the FROM clause of the outer query (also known as
        "inline views") can return any number of rows and columns. This type
        of subquery must always be given an alias.</para>
      <example>
        <title>Example Subquery in FROM Clause (Inline View)</title>
        <programlisting>SELECT a FROM (SELECT Y.b, Y.c FROM Y WHERE Y.d = ‘3’) AS X WHERE a = X.c AND b = X.b</programlisting>
      </example>
    </section>
    <section id="where_subquery">
      <title>Subqueries in the WHERE and HAVING clauses</title>
      <para>Subqueries supported in the criteria of the outer query include subqueries in an IN clause, subqueries using the ANY/SOME or ALL predicate quantifier, and subqueries using the EXISTS predicate. </para>
      <example>
        <title>Example Subquery in WHERE Using EXISTS</title>
        <programlisting>SELECT a FROM X WHERE EXISTS (SELECT 1 FROM Y WHERE c=X.a)</programlisting>
      </example>
      <note><para>EXISTS subqueries should typically follow the convention "SELECT 1 FROM ..." to prevent unnecessary evaluation of select expressions.</para></note>
      <para>
        The following usages of subqueries must each select only one column, but can return any number of rows.
      </para>
      <example>
        <title>Example Subqueries in WHERE Clause</title>
        <programlisting>SELECT a FROM X WHERE a IN (SELECT b FROM Y WHERE c=3) 
SELECT a FROM X WHERE a &gt;= ANY (SELECT b FROM Y WHERE c=3) 
SELECT a FROM X WHERE a &lt; SOME (SELECT b FROM Y WHERE c=4) 
SELECT a FROM X WHERE a = ALL (SELECT b FROM Y WHERE c=2)</programlisting>
      </example>
    </section>
  </section>
</chapter>