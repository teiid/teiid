<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../../../../../../docbook/custom.dtd">
%CustomDTD;
]>
<chapter id="translator_api">
	<title>Developing a Translator</title>
	<sect1>
		<title>Extending the ExecutionFactory Class</title>
		<para>A component called the Connector Manager is controlling access to your translator. This chapter reviews
			the basics of how the Connector Manager interacts with your translator while leaving reference details and
			advanced topics to be covered in later chapters.</para>
        <para>
            A custom translator must extend <emphasis>org.teiid.translator.ExecutionFactory</emphasis>
            to connect and query an enterprise data source. This  extended class must provide a no-arg constructor
            that can be constructed using Java reflection libraries. This Execution Factory need define/override following elements.  
        </para>
        
        <sect2>
            <title>ConnectionFactory</title>
            <para>Defines the "ConnectionFactory" interface that is expected from resource adapter. This defined as part of 
            class definition using generics while extending the "ExecutionFactory" class</para>
        </sect2>
        
        <sect2>
            <title>Connection</title>
            <para>Defines the "Connection" interface that is expected from resource adapter. This defined as part of 
            class definition using generics while extending the "ExecutionFactory" class</para>
        </sect2>        
        
        <sect2>
            <title>Configuration Properties</title>
            <para>Every software program requires some external configuration, that defines ways user can alter the behavior of a program.
             If this translator needs configurable properties define a variable for every property  as an attribute in the extended
             "ExecutionFactory" class. Then define a "get" and "set" methods for each of them. Also, annotate each "get" method with
              <emphasis>@TranslatorProperty</emphasis> annotation and provide the metadata about the property. For example, if you need a
              property called "foo",
                    <programlisting><![CDATA[
String foo = "balh";

@TranslatorProperty(display="Foo property", description="description about Foo") 
public String getFoo() {
    return foo;
}

public void setFoo(String value) {
    return this.foo = value;
}
                    ]]> </programlisting>
                    
                    by providing the annotation on these properties, the Teiid tooling will automatically interrogate and 
                    provide graphical way to configure your
                    Translator. Only "java.lang" and java "primitive" types are supported as Translator properties. 
                    If you do not provide the property during the configuration, the default value defined in this class will be used. 
                    All the properties <emphasis>should</emphasis> have a default value. If you can not provide a default value, 
                    validate all the required properties during the initialization, fail if one is not provided. Repeat this 
                    process for all the properties that you require to configure the Translator.
                </para>
                
                <para>The <emphasis>@TranslatorProperty</emphasis> defines the following metadata that you can define about your property</para>
                <itemizedlist>
                    <listitem>
                        <para>display: Display name of the property</para>
                    </listitem>
                    <listitem>
                        <para>description: Description about the property</para>
                    </listitem>
                    <listitem>
                      <para>required: The property is a required property; or optional and a default is supplied</para>
                    </listitem>
                    <listitem>
                      <para>advanced: This is advanced property; A default must be provided. A property can not be "advanced" and "required" at same time.</para>
                    </listitem>    
                    <listitem>
                      <para>masked: The tools need to mask the property; Do not show in plain text; used for passwords</para>
                    </listitem>                 
                </itemizedlist>                
        </sect2> 
            
        <sect2>
            <title>Initializing the Translator</title>
            <para>Override and implement the <emphasis>start</emphasis> method (be sure to call
                    "super.start()") if your translator needs to do any initializing before it is used by the Teiid engine. This method 
                    will be called by Teiid, once after all the configuration properties set above are injected into the class. </para>
        </sect2>  
        
        <sect2>
            <title>TranslatorCapabilities</title>
            <para>These are various methods that typically begin with method 
                    signature "supports" on the "ExecutionFactory" calss. These methods need to be overridden to describe the execution 
                    capabilities of the Translator. These will be used by the query engine to determine the capabilities of the Translator.
                    More information on what these are in the next chapter.</para>
        </sect2>     
        
        <sect2>
            <title>Execution (and sub-interfaces)</title>
            <para>Based on types of executions you are supporting, the following methods need to be overridden 
            and need to provide implementations for these methods by extending respective interfaces.</para>
            
            <itemizedlist>
                <listitem>
                    <para><emphasis>createResultSetExecution</emphasis> - Define if you are doing read based operation that is 
                    returning a rows of results.</para>
                </listitem>
                <listitem>
                    <para><emphasis>createUpdateExecution</emphasis> - Define if you are doing write based operations.</para>
                </listitem>
                <listitem>
                    <para><emphasis>createProcedureExecution</emphasis> - Define if you are doing procedure based operations.</para>
                </listitem>
            </itemizedlist>       
            <para>You can choose to implement all the execution modes or just what you need. There is no restriction, but it must 
                    implement at least one type of execution. See more details on this below.</para>     
        </sect2>    
        
        <sect2>
            <title>Metadata</title>
            <para>Override and implement the method <emphasis>getMetadata()</emphasis>, if you want to expose the 
                metadata about the source. This defines the tables with its column names, procedures with its parameter that 
                this translator exposing to the query engine. If you expect your translator to work with Dynamic VDB, you must override this
                method, if are always going to use Designer to build the VDB then this is optional. </para>
        </sect2>         
        
        <sect2>
            <title>Logging</title>
            <para>Teiid provides <emphasis>org.teiid.logging.LogManager</emphasis> class for logging purposes. 
                Create a logging context and use the LogManager to log your messages. These will be automatically 
                sent to the main Teiid logs. You can edit the "jboss-log4j.xml" inside "conf" directory of the JBoss AS's profile 
                to add the custom context. Teiid uses Log4J as its underlying logging system.</para>
        </sect2>     
        
        <sect2>
            <title>Exceptions</title>
            <para>If you need to bubble up any exception use <emphasis>org.teiid.translator.TranslatorException</emphasis>
                class.</para>
        </sect2>    
        
        <sect2>
            <title>Default Name</title>
            <para>Finally, you can define a default instance of your Translator by defining the 
                annotation <emphasis>@Translator</emphasis> on the "ExecutionFactory". When you define this, and after deployment 
                a default instance of this 
                Translator is available any VDB that would like to use by just mentioning its name in its "vdb.xml" configuration file.
                VDB can also override the default properties and define another instance of this Translator too. The name you give here is the short 
                name used every where else in the Teiid configuration to refer to this translator.</para>
        </sect2>                        
                        
	</sect1>
    

	<sect1>
		<title>Connections to Source</title>
		<sect2>
			<title>Obtaining connections</title>
			<para>The extended "ExecutionFactory" must implement the <emphasis>getConnection()</emphasis> method to
				allow the Connector Manager to obtain a connection. </para>
		</sect2>
		<sect2>
			<title>Releasing Connections</title>
			<para>Once the Connector Manager has obtained a connection, it will	use that connection only for the
            	lifetime of the request.  When the request has completed, the closeConnection() method called on the "ExecutionFactory".
                You must also override this method to properly close the connection.</para>
			<para>
				In cases (such as when a connection is stateful and expensive to
				create), connections should be pooled. If the resource adapter is JEE JCA connector based, then pooling is automatically
                provided by the JBoss AS container. If your resource adapter does not implement the JEE JCA, then connection pooling 
                sematics are left to the user to define on their own.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Executing Commands</title>
		<sect2>
			<title>Execution Modes</title>
			<para>
				The Teiid query engine uses the "ExecutionFactory" class to obtain the "Execution" interface for the command it is
				executing. The actual queries themselves are sent to translators in the form of a set of objects, which are further
				described in Chapter <link linkend="command_language">Command Language</link>.  
                translators are allowed to support any subset of the available execution modes.
			</para>
			<table frame='all'>
				<title>Types of Execution Modes</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1' colwidth="1*" />
					<colspec colname='c2' colwidth="1*" />
					<colspec colname='c3' colwidth="2*" />
					<thead>
						<row>
							<entry>Execution Interface</entry>
							<entry>Command interface(s)</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<code>ResultSetExecution</code>
							</entry>
							<entry>
								<code>QueryExpression</code>
							</entry>
							<entry>A query corresponding to a SQL SELECT or set query statement.</entry>
						</row>
						<row>
							<entry>
								<code>UpdateExecution</code>
							</entry>
							<entry>
								<code>Insert, Update, Delete, BatchedUpdates</code>
							</entry>
							<entry>An insert, update, or delete, corresponding to a SQL INSERT, UPDATE, or DELETE command
              				</entry>
						</row>
						<row>
							<entry>
								<code>ProcedureExecution</code>
							</entry>
							<entry>
								<code>Call</code>
							</entry>
							<entry>A procedure execution that may return a result set and/or	output values.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>All of the execution interfaces extend the base <code>Execution</code>
				interface that defines how executions are
				cancelled and closed.  ProcedureExecution also extends ResultSetExecution, since procedures may also return resultsets.</para>
		</sect2>
		<sect2>
			<title>ResultSetExecution</title>
			<para>
				Typically most commands executed against translators are QueryExpression.
				While the command is being executed, the translator provides results via the
				ResultSetExecution's "next" method. The "next" method should return null to indicate the end
				of results. Note: the expected batch size can be obtained from the
				ExecutionContext and used as a hint in fetching results from the EIS.
			</para>
		</sect2>
		<sect2>
			<title>Update Execution</title>
			<para>Each execution returns the update count(s) expected by the update command. 
		          If possible BatchedUpdates should be executed atomically.  
		          The ExecutionContext can be used to determine if the execution is already under a transaction.</para>
		</sect2>
		<sect2>
			<title>Procedure Execution</title>
			<para>Procedure commands correspond to the execution of a stored	procedure or some other functional
				construct. A procedure takes zero or more input values and can return a result
				set and zero or more output values.  Examples of procedure execution would be a stored procedure in a
				relational database or a call to a web service.</para>
			<para>If a result set is expected when a procedure is executed, all rows from it will be retrieved via the
				ResultSetExecution interface first. Then, if any output values are expected, they will
				be retrieved via the getOutputParameterValues() method.
			</para>
		</sect2>
        <!-- 
		<sect2>
			<title>Asynchronous Executions</title>
			<para>In some scenarios, a translator needs to execute
				asynchronously and allow the executing thread to perform other work.  To allow this, you should:
			</para>
			<itemizedlist>
				<listitem>
					<para>Set either the SynchronousWorkers annotation or the connector
						binding property SynchWorkers to false - this overrides the default
						behavior in which connector threads stay associated with their
						Execution until the Execution is closed.</para>
				</listitem>
				<listitem>
					<para>Throw a DataNotAvailableExecption during a retrival method, rather than explicitly waiting or sleeping for the results. The
						DataNotAvailableException may take a delay parameter in its
						constructor to indicate how long the system should wait befor polling
						for results.  Any non-negative value is allowed. 
					</para>
				</listitem>
				<listitem>
					<para>Be aware that a connector with asynchronous workers cannot be transactional.</para>
				</listitem>
			</itemizedlist>
		</sect2>
         -->
		<sect2>
			<title>Bulk Execution</title>
			<para>	Non batched <code>Insert, Update, Delete</code>
				commands may have <code>Literal</code> values marked as multiValued if the
				capabilities shows support for BulkUpdate. Commands with
				multiValued <code>Literal</code>s represent multiple executions of the same
				command with different values.  As with BatchedUpdates, bulk operations should be executed atomically if possible.
			</para>
		</sect2>
		<sect2>
			<title>Command Completion</title>
			<para>All normal command executions end with the calling of <code>close()</code> on the Execution object.  Your
				implementation of this method should do the appropriate clean-up work for all state in the Execution	object.</para>
		</sect2>
		<sect2>
			<title>Command Cancellation</title>
			<para>Commands submitted to Teiid may be aborted in several scenarios:</para>
			<itemizedlist>
				<listitem>
					<para>Client cancellation via the JDBC API (or other client APIs)
					</para>
				</listitem>
				<listitem>
					<para>Administrative cancellation</para>
				</listitem>
				<listitem>
					<para>Clean-up during session termination</para>
				</listitem>
				<listitem>
					<para>Clean-up if a query fails during processing</para>
				</listitem>
			</itemizedlist>
			<para>Unlike the other execution methods, which are handled in a single-threaded manner, 
            calls to cancel happen asynchronously with respect to the execution thread.</para>
			<para>Your connector implementation may choose to do nothing in	response to this cancellation message. In
				this instance, Teiid will call close() on the execution object after
				current processing has completed. Implementing the cancel() method allows for faster
				termination of queries being processed and may allow the underlying data source to terminate its operations
				faster as well.</para>
		</sect2>
	</sect1>
    
    <sect1 id="translator_package">
        <title>Packaging</title>
        <para>Once the "ExecutionFactory" class is implemented, package it in a JAR file. The only 
         additional requirement is provide a file called "jboss-beans.xml" in the "META-INF" directory of the JAR file, with
                following contents.
                <programlisting><![CDATA[
                        <?xml version="1.0" encoding="UTF-8"?>
                        <deployment xmlns="urn:jboss:bean-deployer:2.0">
                           
                           <bean name="translator-${name}-template" class="org.teiid.templates.TranslatorDeploymentTemplate">
                              <property name="info"><inject bean="translator-${name}"/></property>
                              <property name="managedObjectFactory"><inject bean="ManagedObjectFactory"/></property>
                           </bean>
                            
                           <bean name="translator-${name}" class="org.teiid.templates.TranslatorTemplateInfo">
                              <constructor factoryMethod="createTemplateInfo">
                                 <factory bean="TranslatorDeploymentTemplateInfoFactory"/>
                                 <parameter class="java.lang.Class">org.teiid.templates.TranslatorTemplateInfo</parameter>
                                 <parameter class="java.lang.Class">${execution-factory-class}</parameter>
                                 <parameter class="java.lang.String">translator-${name}</parameter>
                                 <parameter class="java.lang.String">${name}</parameter>         
                              </constructor>
                           </bean> 
                           
                        </deployment>                
                ]]> </programlisting>
                
                replace ${name} with name of your translator, and replace ${execution-factory-class} with your 
                overridden Execution Factory  class name. This will create Java bean in the JBoss AS, that facilitates to interrogate
                available properties in configuration for this Translator for tooling and Admin API.</para>
    </sect1>
    
    <sect1 id="translator_deploy">
        <title>Deployment</title>
        <para>Copy the JAR file that defines the Translator into "deploy" directory of the JBoss AS's chosen profile, and 
        Translator will be deployed automatically. There is no restriction that, JBoss AS need to be restarted. However, if your Translator
        has external dependencies to other JAR libraries, they need to be placed inside the "lib" directory of the JBoss AS's profile. 
        This will require a restart of the JBoss Server. Another option to avoid the restart is to bundle all the required JAR files into 
        the same JAR file as the Translator. It is user's responsibility to make sure they are not running into any conflicts with their
        dependent libraries with those already exist in the JBoss environment.</para>
    </sect1>    
</chapter>